'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.borderRadiusProps = exports.borderWidthProps = exports.borderStyleProps = exports.sizeProps = exports.spacingProps = exports.colorProps = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createComponent = require('./createComponent');

var _createComponent2 = _interopRequireDefault(_createComponent);

var _ = require('.');

var _cfStyleConst = require('cf-style-const');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line behance/no-deprecated

const sizePropType = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.number]);
const scalePropType = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.array]);

const shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};

const spacingProps = ['padding', 'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop', 'margin', 'marginLeft', 'marginRight', 'marginBottom', 'marginTop', ...Object.keys(shorthandSpacingProps)];

const sizeProps = ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'];

const colorProps = ['color', 'backgroundColor', 'borderColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomColor'];

const borderStyleProps = ['borderStyle', 'borderTopStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle'];

const borderWidthProps = ['borderWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth'];

const borderRadiusProps = ['borderRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderbottomRightRadius'];

const propsSet = new Set(spacingProps.concat(sizeProps, colorProps, borderStyleProps, borderWidthProps, borderRadiusProps, 'fontSize', 'textAlign', 'display'));

// Function to construct the prop types object
const makePropTypes = () => {
  const propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType
  };
  for (let prop of spacingProps.concat(borderWidthProps, borderRadiusProps)) {
    propTypes[prop] = scalePropType;
  }
  for (let prop of colorProps.concat(borderStyleProps)) {
    propTypes[prop] = _propTypes2.default.string;
  }
  for (let prop of sizeProps) {
    propTypes[prop] = sizePropType;
  }
  return propTypes;
};

const styledPropTypes = makePropTypes();

// Fela rule which turns component props into a style object
const propsRule = props => Object.keys(props).filter(prop => propsSet.has(prop)).reduce((o, prop) => (o[prop] = props[prop], o), {});

// Static breakpoints
const bp = [null, `tablet`, `desktop`];

// Ensure value is an array
const arr = n => Array.isArray(n) ? n : [n];

// Tranform value array into object array
// [32, 64] into [{margin: 32}, {margin: 64}]
const dec = props => val => arr(props).reduce((acc, prop) => (acc[prop] = val, acc), {});

// Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]
const media = (d, i) => d !== undefined && d !== null ? bp[i] ? { [bp[i]]: d } : d : null;

// Recursive object merge
const merge = (a, b) => Object.assign({}, a, b, Object.keys(b).reduce((obj, key) => Object.assign(obj, {
  [key]: a[key] !== null && typeof a[key] === 'object' ? merge(a[key], b[key]) : b[key]
}), {}));

const processRules = customRules => {
  let rules = _extends({}, customRules);

  // Expand shorthand spacing properties
  ['padding', 'margin'].forEach(property => {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(position => {
        const attr = `${property}${position}`;
        // Don't overwrite pre-existing longhand properties
        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  });

  // Expand custom shorthand spacing properties
  Object.keys(rules).filter(property => Object.keys(shorthandSpacingProps).includes(property)).forEach(property => {
    Object.assign(rules, shorthandSpacingProps[property].reduce((a, b) => {
      a[b] = rules[property];
      return a;
    }, {}));

    delete rules[property];
  });

  // Convert spacing scales
  rules = Object.keys(rules).filter(property => spacingProps.includes(property)).map(property => {
    const propValues = arr(rules[property]).map(val => _cfStyleConst.variables.space[val] || val).map(dec(property)).map(media).reduce(merge, {});

    delete rules[property];

    return propValues;
  }).reduce(merge, rules);

  // Convert colors to theme
  rules = Object.keys(rules).filter(property => colorProps.includes(property)).map(property => {
    const propValues = arr(rules[property]).map(val => {
      // Handle nested '.' syntax
      if (val.includes('.')) {
        // Attempt to access nested values, otherwise return what was passed
        try {
          return val.split('.').reduce((acc, part) => acc[part], _cfStyleConst.variables.color);
        } catch (e) {
          return val;
        }
      } else if (typeof _cfStyleConst.variables.color[val] === 'string') {
        return _cfStyleConst.variables.color[val];
      }
      return val;
    }).map(dec(property)).map(media).reduce(merge, {});

    delete rules[property];

    return propValues;
  }).reduce(merge, rules);

  // font-size
  if (rules.fontSize) {
    let fontSize = arr(rules.fontSize).map(val => _cfStyleConst.variables.fontSizes[val] || val).map(dec('fontSize')).map(media).reduce(merge, {});

    delete rules.fontSize;

    rules = merge(rules, fontSize);
  }

  // display
  if (rules.display) {
    let display = arr(rules.display).map(dec('display')).map(media).reduce(merge, {});

    delete rules.display;

    rules = merge(rules, display);
  }

  return rules;
};

const emptyRule = () => ({});

const makeStyledRule = (rule = emptyRule) => {
  const combinedRules = (0, _.combineRules)(rule, propsRule);
  return (props, renderer) => processRules(combinedRules(props, renderer));
};

function createStyledComponent(rule, ...rest) {
  const styledRule = makeStyledRule(rule);
  const Component = (0, _createComponent2.default)(styledRule, ...rest);
  Component.propTypes = styledPropTypes;
  return Component;
}

exports.default = createStyledComponent;
exports.colorProps = colorProps;
exports.spacingProps = spacingProps;
exports.sizeProps = sizeProps;
exports.borderStyleProps = borderStyleProps;
exports.borderWidthProps = borderWidthProps;
exports.borderRadiusProps = borderRadiusProps;