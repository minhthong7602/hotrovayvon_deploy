var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import PropTypes from 'prop-types';
import createComponent from './createComponent';
import { combineRules } from '.';

import { variables as theme } from 'cf-style-const'; // eslint-disable-line behance/no-deprecated

var sizePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.array, PropTypes.number]);
var scalePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]);

var shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};

var spacingProps = ['padding', 'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop', 'margin', 'marginLeft', 'marginRight', 'marginBottom', 'marginTop'].concat(_toConsumableArray(Object.keys(shorthandSpacingProps)));

var sizeProps = ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'];

var colorProps = ['color', 'backgroundColor', 'borderColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomColor'];

var borderStyleProps = ['borderStyle', 'borderTopStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle'];

var borderWidthProps = ['borderWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth'];

var borderRadiusProps = ['borderRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderbottomRightRadius'];

var propsSet = new Set(spacingProps.concat(sizeProps, colorProps, borderStyleProps, borderWidthProps, borderRadiusProps, 'fontSize', 'textAlign', 'display'));

// Function to construct the prop types object
var makePropTypes = function makePropTypes() {
  var propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType
  };
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = spacingProps.concat(borderWidthProps, borderRadiusProps)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;

      propTypes[prop] = scalePropType;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = colorProps.concat(borderStyleProps)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _prop = _step2.value;

      propTypes[_prop] = PropTypes.string;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = sizeProps[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _prop2 = _step3.value;

      propTypes[_prop2] = sizePropType;
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return propTypes;
};

var styledPropTypes = makePropTypes();

// Fela rule which turns component props into a style object
var propsRule = function propsRule(props) {
  return Object.keys(props).filter(function (prop) {
    return propsSet.has(prop);
  }).reduce(function (o, prop) {
    return o[prop] = props[prop], o;
  }, {});
};

// Static breakpoints
var bp = [null, 'tablet', 'desktop'];

// Ensure value is an array
var arr = function arr(n) {
  return Array.isArray(n) ? n : [n];
};

// Tranform value array into object array
// [32, 64] into [{margin: 32}, {margin: 64}]
var dec = function dec(props) {
  return function (val) {
    return arr(props).reduce(function (acc, prop) {
      return acc[prop] = val, acc;
    }, {});
  };
};

// Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]
var media = function media(d, i) {
  return d !== undefined && d !== null ? bp[i] ? _defineProperty({}, bp[i], d) : d : null;
};

// Recursive object merge
var merge = function merge(a, b) {
  return Object.assign({}, a, b, Object.keys(b).reduce(function (obj, key) {
    return Object.assign(obj, _defineProperty({}, key, a[key] !== null && _typeof(a[key]) === 'object' ? merge(a[key], b[key]) : b[key]));
  }, {}));
};

var processRules = function processRules(customRules) {
  var rules = _extends({}, customRules);

  // Expand shorthand spacing properties
  ['padding', 'margin'].forEach(function (property) {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(function (position) {
        var attr = '' + property + position;
        // Don't overwrite pre-existing longhand properties
        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  });

  // Expand custom shorthand spacing properties
  Object.keys(rules).filter(function (property) {
    return Object.keys(shorthandSpacingProps).includes(property);
  }).forEach(function (property) {
    Object.assign(rules, shorthandSpacingProps[property].reduce(function (a, b) {
      a[b] = rules[property];
      return a;
    }, {}));

    delete rules[property];
  });

  // Convert spacing scales
  rules = Object.keys(rules).filter(function (property) {
    return spacingProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      return theme.space[val] || val;
    }).map(dec(property)).map(media).reduce(merge, {});

    delete rules[property];

    return propValues;
  }).reduce(merge, rules);

  // Convert colors to theme
  rules = Object.keys(rules).filter(function (property) {
    return colorProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      // Handle nested '.' syntax
      if (val.includes('.')) {
        // Attempt to access nested values, otherwise return what was passed
        try {
          return val.split('.').reduce(function (acc, part) {
            return acc[part];
          }, theme.color);
        } catch (e) {
          return val;
        }
      } else if (typeof theme.color[val] === 'string') {
        return theme.color[val];
      }
      return val;
    }).map(dec(property)).map(media).reduce(merge, {});

    delete rules[property];

    return propValues;
  }).reduce(merge, rules);

  // font-size
  if (rules.fontSize) {
    var fontSize = arr(rules.fontSize).map(function (val) {
      return theme.fontSizes[val] || val;
    }).map(dec('fontSize')).map(media).reduce(merge, {});

    delete rules.fontSize;

    rules = merge(rules, fontSize);
  }

  // display
  if (rules.display) {
    var display = arr(rules.display).map(dec('display')).map(media).reduce(merge, {});

    delete rules.display;

    rules = merge(rules, display);
  }

  return rules;
};

var emptyRule = function emptyRule() {
  return {};
};

var makeStyledRule = function makeStyledRule() {
  var rule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyRule;

  var combinedRules = combineRules(rule, propsRule);
  return function (props, renderer) {
    return processRules(combinedRules(props, renderer));
  };
};

function createStyledComponent(rule) {
  var styledRule = makeStyledRule(rule);

  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var Component = createComponent.apply(undefined, [styledRule].concat(rest));
  Component.propTypes = styledPropTypes;
  return Component;
}

export default createStyledComponent;

export { colorProps, spacingProps, sizeProps, borderStyleProps, borderWidthProps, borderRadiusProps };